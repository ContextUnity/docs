---
title: Brain Integration
description: How Commerce integrates with Brain for knowledge storage and taxonomy
---

# ContextBrain Integration

ContextCommerce integrates with ContextBrain for knowledge storage, semantic search, and taxonomy management. This document explains the integration patterns and configuration.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                     ContextCommerce                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐          │
│  │ Django      │ →  │ Signal      │ →  │ Temporal    │          │
│  │ Model.save()│    │ (post_save) │    │ Workflow    │          │
│  └─────────────┘    └─────────────┘    └──────┬──────┘          │
└────────────────────────────────────────────────┼────────────────┘
                                                 ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Temporal Server                             │
│  SyncProductToBrainWorkflow → upsert_to_brain activity          │
└────────────────────────────────────────────────┬────────────────┘
                                                 ↓
┌─────────────────────────────────────────────────────────────────┐
│                   ContextBrain gRPC Server                       │
│  BrainService + CommerceService → PostgreSQL + pgvector         │
└─────────────────────────────────────────────────────────────────┘
```

## Configuration

### Environment Variables

```bash
# Brain gRPC connection
CONTEXT_BRAIN_URL=localhost:50051
CONTEXT_BRAIN_MODE=grpc  # or 'local' for development

# Temporal (for async sync)
TEMPORAL_URL=localhost:7233

# Enable/disable auto-sync on save
COMMERCE_BRAIN_SYNC_ENABLED=true
```

### Mode Selection

| Mode | Description | Use Case |
|------|-------------|----------|
| `grpc` | Network calls to Brain gRPC server | Production, Docker |
| `local` | Direct library calls, no server needed | Development |

## Signal-Based Sync

When a Product is saved, Django signals automatically queue a Temporal workflow:

```python
# catalogue/signals.py
@receiver(post_save, sender=Product)
def sync_product_to_brain(sender, instance, created, **kwargs):
    if not os.getenv("COMMERCE_BRAIN_SYNC_ENABLED", "true").lower() == "true":
        return
    
    async def _schedule_workflow():
        client = await _get_temporal_client()
        await client.start_workflow(
            SyncProductToBrainWorkflow.run,
            SyncProductParams(product_id=instance.pk),
            id=f"sync-product-{instance.pk}-{timestamp}",
            task_queue="commerce-tasks",
        )
    
    async_to_sync(_schedule_workflow)()
```

### Why Temporal?

1. **Non-blocking**: Django save() returns immediately
2. **Durable**: Workflow continues even if worker crashes
3. **Retry**: Automatic retries on network failures
4. **Observable**: Full history in Temporal UI

## Temporal Workflows

### SyncProductToBrainWorkflow

Syncs Oscar Product to Brain knowledge store.

```python
@workflow.defn
class SyncProductToBrainWorkflow:
    @workflow.run
    async def run(self, params: SyncProductParams) -> dict:
        # 1. Fetch product from Django
        product = await workflow.execute_activity(
            "fetch_product",
            params.product_id,
        )
        
        # 2. Generate embedding (optional)
        embedding = await workflow.execute_activity(
            "generate_embedding",
            product,
        )
        
        # 3. Upsert to Brain
        result = await workflow.execute_activity(
            "upsert_to_brain",
            {**product, "embedding": embedding},
        )
        
        return {"brain_id": result["id"]}
```

### SyncDealerProductToBrainWorkflow

Syncs Harvester DealerProduct to Brain.

```python
@workflow.defn
class SyncDealerProductToBrainWorkflow:
    @workflow.run
    async def run(self, params: SyncDealerProductParams) -> dict:
        product = await workflow.execute_activity("fetch_dealer_product", ...)
        result = await workflow.execute_activity("upsert_to_brain", ...)
        return {"brain_id": result["id"]}
```

## Running the Commerce Worker

The Commerce worker processes Brain sync workflows:

```bash
# Via mise (recommended)
mise run commerce_worker

# Via Python
cd contextcommerce
uv run python -m temporal.worker
```

## Local Development Mode

For development without running Brain gRPC server:

```bash
# Set local mode
export CONTEXT_BRAIN_MODE=local

# Disable auto-sync (optional)
export COMMERCE_BRAIN_SYNC_ENABLED=false

# Run Django
./dev.sh
```

In local mode, BrainClient calls go directly to the Brain library without network overhead.

## Hybrid Search in Matcher

The product matcher uses both local and Brain search:

```python
def query_brain_node(state: MatcherState) -> dict:
    async def _query():
        client = BrainClient()
        results = await client.search(
            tenant_id=state.get("tenant_id", "default"),
            query_text=state["query"],
            limit=10,
        )
        return [...]
    
    candidates = async_to_sync(_query)()
    return {"candidates": candidates}
```

## pgvector Integration

Commerce can also use local pgvector for fast search without Brain:

```python
# catalogue/models.py
class Product(AbstractProduct):
    # Local embedding for fast search
    embedding = VectorField(dimensions=1536, null=True)
    embedding_model = models.CharField(max_length=50, default="text-embedding-3-small")
    
    @classmethod
    def semantic_search(cls, query_embedding: list[float], limit: int = 10):
        from pgvector.django import CosineDistance
        return (
            cls.objects.filter(embedding__isnull=False)
            .annotate(distance=CosineDistance("embedding", query_embedding))
            .order_by("distance")[:limit]
        )
```

## Troubleshooting

### "Connection refused" on Brain sync

1. Check Brain is running: `lsof -i :50051`
2. Check mode: `echo $CONTEXT_BRAIN_MODE`
3. Switch to local mode: `export CONTEXT_BRAIN_MODE=local`

### Temporal workflow stuck

1. Check worker is running: `mise run commerce_worker`
2. Check Temporal UI: `http://localhost:8233`
3. Check workflow history for errors

### Signals not firing

1. Check feature flag: `echo $COMMERCE_BRAIN_SYNC_ENABLED`
2. Check Django app is in INSTALLED_APPS
3. Check signals.py is imported in apps.py

## See Also

- [Temporal Workflows](/guides/temporal/)
- [Harvester Integration](/ingestion/harvester/)
- [BrainClient SDK](/reference/brain-client/)
